Если ваш мод предполагает создание своей логики, то вам скорее всего понадобится делать задержки между определёнными действиями, однако майнкрафт **НЕ** потокобезопасен, из-за чего делается это не так просто как можно подумать.
## Принцип работы отложенных действий

Забудьте про задержку прямо внутри функции - майнкрафт скорее всего даже не запустится с таким кодом, а если и запустится, то игра будет банально зависать на время указанной задержки. Использование дополнительных потоков тоже **запрещено**, так как все действия в мире майнкрафта обрабатываются в одном цикле 20 раз в секунду (тики), и если попытаться встроить свои изменения в мир между тиками, то игра просто крашнится.
Тут в дело и вступают отложенные действия - мы откладываем желаемое действие куда-нибудь, а выполняем его только когда наступит нужный нам тик или пройдёт определённая задержка. Это может создать некоторые сложности при использовании в первый раз, однако ничего сложного в этом нет.
## Как создать отложенное действие

К сожалению в майнкрафте нет нормальных встроенных методов для откладывания действий (или я про них пока не знаю) **ДОПОЛНИТЬ**, но вы можете создать их сами - что иногда даже удобнее. 

В первую очередь создайте класс **DelayedTaskManager**, и над ним укажите аннотацию: @Mod.EventBusSubscriber(modid = "ваш mod_id") - это нужно для того, чтобы майнкрафт видел методы под аннотацией @**SubscribeEvent**.  
далее нужно получить доступ к основному циклу с тиками. Для этого нужно подключится к событию **TickEvent.ServerTickEvent** при помощи @**SubscribeEvent**, про который более подробно можно прочитать тут: [[SubscribeEvent]]. Выглядеть это должно примерно так:
```java
@Mod.EventBusSubscriber(modid = "myfirstmod")  
public class DelayedTaskManager {    
  
    @SubscribeEvent  
    public static void onServerTick(TickEvent.ServerTickEvent event) {
    
    }
}
```

Всё! Теперь вы можете делать в этом методе всё что захотите, и оно будет выполнятся каждый тик существования сервера.

Но пока что создавать отложенные действия тут негде и, к счастью или к сожалению, вам придётся сделать свою реализацию этого.
Хотя если вы не хотите этого делать сами то можете взять мою реализацию набросанную на скорую руку:
```java
@Mod.EventBusSubscriber(modid = "myfirstmod")  
public class DelayedTaskManager {  
    private static HashMap<Integer, List<Runnable>> tasks = new HashMap<>();  
  
    @SubscribeEvent  
    public static void onServerTick(TickEvent.ServerTickEvent event) {  
        if (event.phase == TickEvent.Phase.END) {  
            Integer currentTick = event.getServer().getTickCount();  
            if (!tasks.containsKey(currentTick)) {return;}  
            for (Runnable task : tasks.get(currentTick)) {  
                task.run();  
            }  
            tasks.remove(currentTick);  
        }  
    }  
  
    public static void putTask(Integer tick, Runnable task) {  
        if (!tasks.containsKey(tick)) {  
            tasks.put(tick, new ArrayList<>());  
        }  
        tasks.get(tick).add(task);  
    }  
}
```

Теперь чтобы создать отложенную задачу используйте метод putTask, вот пример использования:
```java
DelayedTaskManager.putTask(level.getServer().getTickCount() + 100, () -> {  
    player.sendSystemMessage(Component.literal("Have fun!"));  
});
```

Этот метод принимает 2 аргумента: 
1) tick - серверный тик, на который придётся отложенное событие - учтите, что это абсолютное значение, а значит для корректной работы нужно прибавить нужную задержку (в тиках) к уже прошедшему на сервере числу тиков (можно получить из MinecraftServer при помощи метода getTickCount())
2) Сама функция, которую вы хотите выполнить в формате Runnable
### У этой реализации есть недостаток!

При перезапуске сервера все отложенные действия слетят - учитывайте это, если это важно в вашем моде!